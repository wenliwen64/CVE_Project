//xianglei's analysis macro: analyze the picoDST generated by StMcV0Maker. 

//#ifndef __CINT__
#include "TROOT.h"
#include "TMath.h"
#include "TSystem.h"
#include "TApplication.h"
#include "TFile.h"
#include "TError.h"
#include "TTree.h"
#include "TChain.h"
#include "TH1.h"
#include "TH2.h"
#include "TF1.h"
#include "TStyle.h"
#include "TCanvas.h"
#include "TString.h"
#include "Riostream.h"
#include "v0dst.h"
#include "v0dst.C"
#include <sstream>
#include <string>
#include <cstdlib>
#include "StThreeVectorF.hh"
#include "StPhysicalHelixD.hh"
using namespace std;
//#endif

//handy routine to convert integer to c++ string, then we can apply operators on it.
//inline string stringify(int x){ ostringstream o; o << x; return o.str(); } 
string stringify(int x){ ostringstream o; o << x; return o.str(); } 
//a handy routine to chain some block files listed in filelist.
TChain* ChainThem(char* filelist, char* treename, int nlist = 0, int block = 100);

const int kGroup   = 1;
//const int kCentBin = 7;
const int kCentBin = 9;
const int kPtBin = 21;
//const int kPtBin = 14;
Double_t grpbd[kGroup+1]={0.,13060000.};
//Float_t centbd[kGroup][kCentBin+1]={{6.5,23.5,66.5,102.5,152.5,220.5,263.5,20000.}}; //from H. Masui
//Float_t centbd[kGroup][kCentBin+1]={{0.5,6.5,11.5,200.},{0.5,7.5,12.5,200.},{0.5,6.5,10.5,200.}}; //from H. Masui
Float_t  ptbd[kPtBin+1]={0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0,2.3,2.6,3.0,3.4,3.8,4.2,4.8,5.4,6.0,7.0,8.0,10.0};
//Float_t  ptbd[kPtBin+1]={0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0,2.5,3.0,3.5,4.0,4.7};

Double_t getWeight(Int_t cent, Float_t pt);

void cuts_fp_ks(int nlist, int block){

   //firstly use the TTree::MakeClass to generate a handy wrapper class.
   //modify it (the array size) and load it here
//#ifdef __CINT__
   gROOT->LoadMacro("v0dst.C+");
//#endif

   TChain * t = ChainThem("./picodst_ks_exp.list","McV0PicoDst",nlist,block);
   if(!t){ cout<<"ERROR: no files are added to the chain!"<<endl; return; }

   //bound them together
   v0dst dst(t);

   //histograms
   //TString Dir("");
   string Dir ="";
   //TString Name("mcks_fp");
   string Name = "mcks_fp";
   string temp = Dir+Name+stringify(nlist)+".cuts.histo.root";
   TFile ohm(temp.c_str(),"recreate");

   Float_t pdgmass = 0.497614;
   Float_t masswidth = 0.07+0.01;

   //QA histograms about event-wise information
   TH1F * hmNRefMult = new TH1F("hmNRefMult","Number of reference multiplicity",4000,0,1000);
   TH1F * hmVertexZ  = new TH1F("hmVertexZ","Vertex Z", 120,-30,30);
   TH1F * hmVertexR  = new TH1F("hmVertexR","Vertex R", 200,-10,10);
   TH1F * hmNMcV0    = new TH1F("hmNMcV0","Number of MC V0",100,0,100);
   TH1F * hmNRcV0    = new TH1F("hmNRcV0","Number of RC V0",100,0,100);
   TH2F * hmNMcRcV0  = new TH2F("hmNMcRcV0","Number of Mc and Rc V0",100,0,100,50,0,50);
   //QA histograms about MC V0
   TH1F * hmMcV0Pt   = new TH1F("hmMcV0Pt","Pt of MC V0", 100,0,10);
   TH1F * hmMcV0Rap   = new TH1F("hmMcV0Rap","Rapidity of MC V0", 100,-2,2);
   //QA histograms about RC V0
   TH1F * hmRcV0Pt   = new TH1F("hmRcV0Pt","Pt of RC V0", 100,-5,5);
   TH1F * hmRcV0Rap   = new TH1F("hmRcV0Rap","Rapidity of RC V0", 100,-1,1);
   
   //book histograms
   TH1F * hmInvMass = new TH1F("hmInvMass","Invariant mass", 300,pdgmass-masswidth,pdgmass+masswidth);
   TH1F * hmV0InvMass = new TH1F("hmV0InvMass","Invariant mass of V0", 300,pdgmass-masswidth,pdgmass+masswidth);
   TH1F * hmDca1to2 = new TH1F("hmDca1to2","Dca of daughters", 200,0,2);
   TH1F * hmDcav0tobach = new TH1F("hmDcav0tobach","Dca of v0 to bachelor", 200,0,2);
   TH1F * hmXiDeclen = new TH1F("hmXiDeclen","Decay lenth of xi", 200,0,100);
   TH1F * hmDeclen = new TH1F("hmDeclen","Decay lenth of v0", 200,0,100);
   TH1F * hmDeclenDiff = new TH1F("hmDeclenDiff","Decay lenth of v0-xi", 200,-40,40);
   TH1F * hmXiDca = new TH1F("hmXiDca","Dca to PV of xi", 200,0,5.5);
   TH1F * hmV0Dca = new TH1F("hmV0Dca","Dca to PV of v0", 200,0,5.5);
   TH1F * hmDau1Dca = new TH1F("hmDau1Dca","Dca to PV of dau1", 200,0,15);
   TH1F * hmDau2Dca = new TH1F("hmDau2Dca","Dca to PV of dau2", 200,0,25);
   TH1F * hmBachDca = new TH1F("hmBachDca","Dca to PV of Bach", 200,0,25);
   TH1F * hmsinth = new TH1F("hmsinth","xi sinth", 200,0,0.3);
   TH1F * hmTrack1nHits = new TH1F("hmTrack1nHits","nHits of Track 1", 100,0,100);
   TH1F * hmTrack2nHits = new TH1F("hmTrack2nHits","nHits of Track 2", 100,0,100);
   
   TH2I * hmSumMcV0 = new TH2I("hmSumMcV0", "MC V0 counts in different cent and pt bin", kCentBin,0,kCentBin,kPtBin,0,kPtBin);
   TH2I * hmSumRcV0 = new TH2I("hmSumRcV0", "RC V0 counts in different cent and pt bin", kCentBin,0,kCentBin,kPtBin,0,kPtBin);

   Double_t wMcCount[kCentBin][kPtBin];
   Double_t wRcCount[kCentBin][kPtBin];
   Double_t wRcOutCount[kCentBin][kPtBin];
   Double_t w2McCount[kCentBin][kPtBin];
   Double_t w2RcCount[kCentBin][kPtBin];
   Double_t w2RcOutCount[kCentBin][kPtBin];
   
   TH1F * hmIM[kCentBin][kPtBin];
   TH1F * hmIMCent[kCentBin];
   for(Int_t iIM=0; iIM<kCentBin; iIM++){
	//TString hName("hmInvMass");
	//TString hTitle("Invariant mass for ");
	string hName = "hmInvMass";
	string hTitle = "Invariant mass for ";

	hName = hName + "Cent" + stringify(iIM);
	hTitle = hTitle + "centrality bin " + stringify(iIM);
	hmIMCent[iIM] = new TH1F(hName.c_str(), hTitle.c_str(), 200, pdgmass-masswidth, pdgmass+masswidth);
	for(Int_t jIM=0; jIM<kPtBin; jIM++){
	   //TString hName("hmInvMass");
	   string hName = "hmInvMass";
	   //TString hTitle("Invariant mass for ");
	   string hTitle = "Invariant mass for ";
	   hName = hName + "Cent" + stringify(iIM) + "Pt" + stringify(jIM);
	   hTitle = hTitle + "centrality bin " + stringify(iIM) + " pt bin " + stringify(jIM);
	   hmIM[iIM][jIM] = new TH1F(hName.c_str(), hTitle.c_str(), 200, pdgmass-masswidth, pdgmass+masswidth);

	   wMcCount[iIM][jIM]=0;
	   wRcCount[iIM][jIM]=0;
	   wRcOutCount[iIM][jIM]=0;
	   w2McCount[iIM][jIM]=0;
	   w2RcCount[iIM][jIM]=0;
	   w2RcOutCount[iIM][jIM]=0;
	}
   }
 
   //histogram for cent bin and pt bin
   TH1D * hmGroup = new TH1D("hmGroup","Run Group finder",kGroup,grpbd);
   TH1F * hmCent[kGroup];
   for(Int_t i=0;i<kGroup;i++){
      //TString hName("hmCent");
      string hName = "hmCent";
      hName = hName + stringify(i);
      //TString hTitle("Centrality bin finder for group ");
      string hTitle = "Centrality bin finder for group ";
      hTitle = hTitle + stringify(i);
      //hmCent[i] = new TH1F(hName,hTitle,kCentBin,centbd[i]);
   }
   TH1F * hmPt = new TH1F("hmPt","Pt bin finder",kPtBin,ptbd);

   int mcidvec[200];
   
   //event loop (copy from wrapper class' Loop method
   Long64_t nentries = t->GetEntriesFast();
   Long64_t nbytes = 0, nb = 0;
   for(Long64_t jentry=0; jentry<nentries;jentry++) {
	Long64_t ientry = dst.LoadTree(jentry);
	if (ientry < 0) break;
	nb = t->GetEntry(jentry);   nbytes += nb;

	if(jentry%100==0)cout<<jentry<<" "<<nentries<<endl;

	//if(fabs(dst.primvertexX*dst.primvertexX+dst.primvertexY*dst.primvertexY)>4.0)continue;
	if(fabs(dst.primvertexZ)>40.0)continue;
	//fill histograms
	//Int_t centbin = getCentBin(dst.nrefmult);
	Int_t grp = hmGroup->FindBin(dst.runnumber)-1;
      //cout<<dst.runnumber<<" "<<grp<<endl;
      hmGroup->Fill(dst.runnumber);
      if(grp<0 || grp >= kGroup) continue;
      //Int_t centbin = hmCent[grp]->FindBin(dst.nrefmult)-1;
      int centbin = dst.centBin9;
      //cout<<"============this is centbin "<<centbin<<std::endl;
      //if(centbin != 0) std::cout<<"=====================this is centbin "<< centbin <<std::endl;
      //hmCent[grp]->Fill(dst.nrefmult);
      //if(centbin==kCentBin)centbin = -1;


	hmNRefMult->Fill(dst.nrefmult);
	hmVertexZ->Fill(dst.primvertexZ);
	hmVertexR->Fill(sqrt(dst.primvertexX*dst.primvertexX + dst.primvertexY*dst.primvertexY));
	//hmNMcXi->Fill(dst.nmcxi);
	//hmNRcXi->Fill(dst.nxi);
	//hmNMcRcXi->Fill(dst.nmcxi,dst.nxi);

        // Initialize the refmultcorrector 
        //refmultCorrUtil -> init(dst.runnumber);
        //refmultCorrUtil -> initEvent(dst.nrefmult, dst.primvertexZ);
        //const Int_t cent9 = refmultCorrUtil -> getCentralityBin9();
           //std::cout<<"done event"<<jentry<<std::endl;
	for(Int_t i=0;i<dst.nmcv0;i++){
	   mcidvec[i] = dst.mcv0id[i];
	   if(fabs(dst.mcv0rapidity[i])>0.5)continue;//the origin code
//	   if(fabs(dst.mcv0rapidity[i])>1.0)continue;//I change


	   Int_t ptbin = hmPt->FindBin(dst.mcv0pt[i])-1;
	   if(ptbin==kPtBin)ptbin = -1;
           //std::cout<<ptbin<<" pt bin"<<std::endl;
           //std::cout<<centbin<<" cent bin"<<std::endl;
	   if(centbin < 0 || ptbin < 0)continue;
	   //hmMcXiPt->Fill(dst.mcv0pt[i]);
	   //hmMcXiRap->Fill(dst.mcv0rapidity[i]);
	   //hmSumMcXi->Fill(centbin,ptbin);
	   Double_t wgt = getWeight(centbin, dst.mcv0pt[i]);
	   wMcCount[centbin][ptbin] += wgt; 
	   w2McCount[centbin][ptbin] += wgt*wgt; 
           //std::cout<<"Got One!"<<std::endl; 
	}
        //std::cout<<"done mc"<<jentry<<std::endl;	
	for(Int_t i = 0; i < dst.nv0; i++){
	   /*
	   hmInvMass->Fill(dst.ximass[i]);
	   hmV0InvMass->Fill(dst.v0mass[i]);
	   hmDca1to2->Fill(dst.dca1to2[i]);
	   hmDcav0tobach->Fill(dst.dcav0tobach[i]);
	   hmXiDeclen->Fill(dst.xideclen[i]);
	   hmDeclen->Fill(dst.v0declen[i]);
	   hmDeclenDiff->Fill(dst.v0declen[i]-dst.xideclen[i]);
	   hmV0Dca->Fill(dst.v0dca[i]);
	   hmXiDca->Fill(dst.xidca[i]);
	   hmDau1Dca->Fill(dst.dau1dca[i]);
	   hmDau2Dca->Fill(dst.dau2dca[i]);
	   hmBachDca->Fill(dst.bachdca[i]);
	   hmsinth->Fill(dst.xisinth[i]);
	   */

//	   if(fabs(dst.v0rapidity[i])>1.0)continue;

   //Liwen, For 200GeV Ks0 2011... 
                 
                //std::cout<<"so far so good=====0"<<std::endl;
                if(fabs(dst.v0mass[i]-0.497614) > 0.01) continue;
                //std::cout<<"so far so good=====1"<<std::endl;
                //if(dst.v0pt[i] < 0.02 || dst.v0pt[i] > 2.0) continue;
                if(dst.v0pt[i] < 0.02) continue;
                if(fabs(dst.v0eta[i]) > 1.0) continue;
                if(fabs(dst.v0rapidity[i]) > 0.5) continue;
                if(dst.v0declen[i] < 4.0) continue;
                if(dst.v0dca[i] > 0.7) continue;
                //std::cout<<"so far so good"<<std::endl;
                //if(fabs(dst.dau1nsigma[i]) > 3.0) continue; //both are zero
                //if(fabs(dst.dau2nsigma[i]) > 3.0) continue;
                if(dst.dau1dca[i]<1.2) continue;
                if(dst.dau2dca[i]<1.2) continue;
                if(dst.dca1to2[i]>0.8) continue;
         //cout<<"Got one after topological cuts" <<endl;

/*
                        if(centbin==3){if(dst.v0dca[i]>0.75)continue;}
                        if(centbin==4){if(dst.v0dca[i]>0.67)continue;}
                        if(centbin==5){if(dst.v0dca[i]>0.575)continue;}
                        if(centbin==6){if(dst.v0dca[i]>0.5)continue;}
*/
 
	   StThreeVectorF PV(dst.primvertexX,dst.primvertexY,dst.primvertexZ);
	   StThreeVectorF xv0(dst.v0x[i],dst.v0y[i],dst.v0z[i]);
	   StThreeVectorF pv0(dst.v0px[i],dst.v0py[i],dst.v0pz[i]);
	   StPhysicalHelixD helixv0(pv0,xv0,0,0);
	   StThreeVectorF xv0toPV = xv0 - PV;
	   double rdotp = xv0toPV.dot(pv0) ;
	   if(rdotp<=0)continue;

           //std::cout<<"Got one after topolotical cuts"<<std::endl;
/*	   //veto lambda //for Ks analysis
	   double mMass1=0.93827;
	   double mMass2=0.13957;
	   double oe1 = sqrt(dst.dau1px[i]*dst.dau1px[i]+dst.dau1py[i]*dst.dau1py[i]+dst.dau1pz[i]*dst.dau1pz[i]+ mMass1*mMass1);
	   double oe2 = sqrt(dst.dau2px[i]*dst.dau2px[i]+dst.dau2py[i]*dst.dau2py[i]+dst.dau2pz[i]*dst.dau2pz[i]+ mMass2*mMass2);
	   double v0mass = sqrt(mMass1*mMass1 + mMass2*mMass2 + 2.*oe1*oe2 - 2.*(dst.dau1px[i]*dst.dau2px[i]+dst.dau1py[i]*dst.dau2py[i]+dst.dau1pz[i]*dst.dau2pz[i]));
	   if(fabs(v0mass-1.1157)<0.015)continue;
	   mMass1=0.13957;
	   mMass2=0.93827;
	   oe1 = sqrt(dst.dau1px[i]*dst.dau1px[i]+dst.dau1py[i]*dst.dau1py[i]+dst.dau1pz[i]*dst.dau1pz[i]+ mMass1*mMass1);
	   oe2 = sqrt(dst.dau2px[i]*dst.dau2px[i]+dst.dau2py[i]*dst.dau2py[i]+dst.dau2pz[i]*dst.dau2pz[i]+ mMass2*mMass2);
	   v0mass = sqrt(mMass1*mMass1 + mMass2*mMass2 + 2.*oe1*oe2 - 2.*(dst.dau1px[i]*dst.dau2px[i]+dst.dau1py[i]*dst.dau2py[i]+dst.dau1pz[i]*dst.dau2pz[i]));
	   if(fabs(v0mass-1.1157)<0.015)continue;
*/
	   //find the MC v0 index according to their ids
	   int ind = -1;
	   for(int ik=0;ik<dst.nmcv0;ik++)
		if(mcidvec[ik]==dst.v0mcid[i]){ind = ik; break;}// find out the corresponding mc original accurate event

	   hmRcV0Pt->Fill(dst.v0pt[i]-dst.mcv0pt[ind]);
	   hmRcV0Rap->Fill(dst.v0rapidity[i]-dst.mcv0rapidity[ind]);

	   if(centbin>=0)hmIMCent[centbin]->Fill(dst.v0mass[i]);
	   Int_t ptbin = hmPt->FindBin(dst.v0pt[i])-1;
	   if(ptbin==kPtBin)ptbin = -1;
	   if(centbin<0 || ptbin<0)continue;
	   hmIM[centbin][ptbin]->Fill(dst.v0mass[i]);
	   //hmSumRcXi->Fill(centbin,ptbin);
	   
	   Double_t wgtrc = getWeight(centbin, dst.mcv0pt[ind]);
	   Int_t mcptbin = hmPt->FindBin(dst.mcv0pt[ind])-1;
           //std::cout<<"Got One!"<<std::endl;
	   if(mcptbin == ptbin){
		wRcCount[centbin][ptbin] += wgtrc;
		//std::cout<<"real event "<<wRcCount[centbin][ptbin]<<std::endl;
		w2RcCount[centbin][ptbin] += wgtrc*wgtrc;
		//std::cout<<"real event "<<w2RcCount[centbin][ptbin]<<std::endl;
	   }
	   else{
		wRcOutCount[centbin][ptbin] += wgtrc;
		w2RcOutCount[centbin][ptbin] += wgtrc*wgtrc;
	   }

           if(ind>-1)
           {
                hmV0InvMass->Fill(dst.v0mass[i]);
                hmDca1to2->Fill(dst.dca1to2[i],wgtrc);
                hmDeclen->Fill(dst.v0declen[i],wgtrc);
                hmV0Dca->Fill(dst.v0dca[i],wgtrc);
                hmDau1Dca->Fill(dst.dau1dca[i],wgtrc);
                hmDau2Dca->Fill(dst.dau2dca[i],wgtrc);
                hmTrack1nHits->Fill(dst.dau1nhits[i],wgtrc);
                hmTrack2nHits->Fill(dst.dau2nhits[i],wgtrc);
           }

	}
   }

   ofstream oweight("weight_ks_fp_test.txt");
   
   for(int i=0;i<kCentBin;i++)
	for(int j=0;j<kPtBin;j++){
	   Float_t eff = (wRcCount[i][j]+wRcOutCount[i][j])/wMcCount[i][j];
	   Float_t wRcNoCount = wMcCount[i][j]-wRcCount[i][j];
	   Float_t w2RcNoCount = w2McCount[i][j]-w2RcCount[i][j];
	   Float_t efferr = sqrt(w2RcCount[i][j]*(wRcNoCount-wRcOutCount[i][j])*(wRcNoCount-wRcOutCount[i][j])+w2RcNoCount*(wRcCount[i][j]+wRcOutCount[i][j])*(wRcCount[i][j]+wRcOutCount[i][j]) + w2RcOutCount[i][j]*wMcCount[i][j]*wMcCount[i][j])/wMcCount[i][j]/wMcCount[i][j];
	   cout<<i<<" "<<j<<" "<<wMcCount[i][j]<<" "<<wRcCount[i][j]<<" "<<wRcOutCount[i][j]<<" "<<w2McCount[i][j]<<" "<<w2RcCount[i][j]<<" "<<w2RcOutCount[i][j]<<" "<<eff<<endl;//" "<<efferr/eff<<endl;
	   oweight<<i<<" "<<j<<" "<<wMcCount[i][j]<<" "<<wRcCount[i][j]<<" "<<w2McCount[i][j]<<" "<<w2RcCount[i][j]<<" "<<eff<<" "<<efferr<<endl;///eff<<endl;
	}

   oweight.close();

   ohm.Write();	//save all booked histograms
   ohm.Close();
   delete t;
}

Double_t getWeight(Int_t cent, Float_t pt){
   Double_t wgt;
   //parameterize levy function to supply the weight
   
   static TF1 levy("levy","x*(([0]*([1]-1)*([1]-2))/(2.0*3.141592654*[1]*[2]*([1]*[2]+0.497614*([1]-2))))/(1+((TMath::Sqrt((x*x)+(0.497614*0.497614))-0.497614)/([1]*[2])))^[1]",0.,8.);
   ifstream ipara("Levy_parameter_Ks0.txt");
   Double_t yield[kCentBin]={0};
   Double_t pwindex[kCentBin]={0};
   Double_t slope[kCentBin]={0};
   for(int i = 0;i<kCentBin;i++)
        ipara>>yield[i]>>pwindex[i]>>slope[i];
   ipara.close();
   levy.SetParameters(yield[cent],pwindex[cent],slope[cent]);
 
   wgt = levy.Eval(pt);
   
/*
   static TF1 dexp("dexp","x*[0]/2.0/3.141592654*([1]/[2]/(1.115683+[2])*exp(-(sqrt(x*x+1.115683*1.115683)-1.115683)/[2])+(1.-[1])/[3]/(1.115683+[3])*exp(-(sqrt(x*x+1.115683*1.115683)-1.115683)/[3]))",0,10.0);
   dexp.SetParameters(1.10655e+02,5.10130e-02,5.98316e-01,2.83653e-01);
   wgt = dexp.Eval(pt);
*/
   //return wgt;
   return 1;
}

TChain* ChainThem(char* filelist, char* treename, int nlist, int block){

   TChain *globChain = new TChain(treename);

   cout << ">>> Load Chain from file: " << filelist << endl;
   ifstream fList(filelist);
   if (!fList)
   {
	cout << "!!! Can't open file " << filelist << endl;
	return NULL;
   }

   int Ncount = 0;
   int Nfiles = 0;
   char lineFromFile[255];
   while(fList.getline(lineFromFile, 250))
   {
	Ncount++;
	if(Ncount<=nlist*block)continue;
	if(Ncount>(nlist+1)*block)break;
	if(globChain->Add(lineFromFile,0)){
	   cout << ">> File '" << lineFromFile << "' has been loaded" << endl;
	   Nfiles ++;
	}
	else
	   cout << ">> Can't load file '" << lineFromFile << "'" << endl;
   }

   cout << ">> Total number of entries: " << globChain->GetEntriesFast() << endl;
   fList.close();

   if(Nfiles == 0){
	delete globChain;
	return NULL;
   }

   return globChain;
}
